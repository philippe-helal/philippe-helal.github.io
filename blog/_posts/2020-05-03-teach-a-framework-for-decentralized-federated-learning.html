---
excerpt: |
    Federated learning is a promising concept for owners of machine-learning
    models and owners of training data alike. Current federated learning
    approaches require the model owner to have knowledge of, and access to,
    the network of training devices. This requires him to create persistent
    connections to the devices and develop automated procedures for
    generating the data, while providing no incentive for data owners to
    participate. We outline a framework for orchestrating federated learning
    and rewarding data owners that does not rely on trust or knowledge
    between the model owner and data owners.
author:
- Philippe Helal
- Yannis Ikni
bibliography:
- 'bib.bib'
date: 3 May 2020
key: 'teach-a-framework-for-decentralized-federated-learning'
mathjax: True
mathjax_autoNumber: True
tags: 'paper machine-learning blockchain federated-learning'
title: 'Teach: A framework for decentralized federated learning'
---
<h1 id="s:introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Machine learning is gaining an ever-growing importance in our lives. As the field is developing, so too are its applications. The traditional machine learning paradigm consists of conceiving a machine learning model, collecting and storing some training data in a central location, then training the model on this data. While this process can be distributed among many processing units, it is still conducted by a single economic entity. This process is appropriate in many settings where quality data is available in large quantities such as image classification, process optimization, or business applications. In other applications, such data is scattered across external devices, each holding a small local dataset that could be used for training. Data generated by mobile applications, or sensitive data such as health data are such examples. In these cases, the high value of the data prevents the model owner from collecting it in a central location.</p>
<p>Federated learning <span class="citation" data-cites="mcmahan2016communication">(McMahan et al. <a href="#ref-mcmahan2016communication" role="doc-biblioref">2016</a>)</span> is a new machine-learning paradigm where the model owner and the data owner(s) (also referred to as clients or workers) are separate economic entities. Rather than sharing data between parties, training works as such: the model owner <span class="math inline">\(MO\)</span> initiates his model. Eligible clients (defined as connected to a power source and a reliable network connection) declare themselves to <span class="math inline">\(MO\)</span> as being available for training. <span class="math inline">\(MO\)</span> then randomly selects a subset of those workers and sends them the model. Each client then trains the model on his own local dataset and sends back the gradient updates to <span class="math inline">\(MO\)</span>. Once all updates are received, <span class="math inline">\(MO\)</span> computes the average update weighted by the number of training samples used by each client, then updates his model. This process is repeated as long as <span class="math inline">\(MO\)</span> needs to improve his model. This process works under certain conditions.</p>
<ol>
<li><p><span class="math inline">\(MO\)</span> and each client must have an established way of connecting to each other.</p></li>
<li><p><span class="math inline">\(MO\)</span> can either trust or validate the quality of each client’s data. In other words, he is confident that the data points are independent and identically distributed (i.i.d).</p></li>
<li><p>Clients must be willing to participate in the training and must trust the aggregation process.</p></li>
</ol>
<p>Because of these conditions, the range of federated learning applications today is limited. It is best used by software developers, who control the data generated by their application, and can connect to a central server at will. This allows them to meet conditions 1 and 2. Furthermore, with such applications, participation is generally not explicitly asked of the clients, allowing <span class="math inline">\(MO\)</span> to bypass condition 3.</p>
<p>In order to generalize federated learning to more domains and data sources, one must devise an approach that meets the three conditions above, without needing to control the generation of clients’ data. In this paper, we propose a framework for orchestrating the training procedure that is transparent and provably honest. This paper is structured as such: Section <a href="#s:related-work" data-reference-type="ref" data-reference="s:related-work">2</a> explores previous work into developing such a method; section <a href="#s:design" data-reference-type="ref" data-reference="s:design">3</a> introduces our proposal for connecting the parties, exchanging model updates, and rewarding clients; section <a href="#s:local-training-loss-as-a-contribution-function" data-reference-type="ref" data-reference="s:local-training-loss-as-a-contribution-function">4</a> evaluates our proposal with a training simulation; and section <a href="#s:limitations-and-future-work" data-reference-type="ref" data-reference="s:limitations-and-future-work">5</a> explores future work to be done in this direction.</p>
<h1 id="s:related-work"><span class="header-section-number">2</span> Related Work</h1>
<p>Many contributions have been made towards generalizing the federated learning process. We summarize them here.</p>
<p>BlockFL <span class="citation" data-cites="kim2019blockchained">(Kim et al. <a href="#ref-kim2019blockchained" role="doc-biblioref">2019</a>)</span> is an on-chain aggregation mechanism, where model updates are sent to miners, who then add them to a block and propagate them to the network. Aggregation is done on-chain via the FedAvg algorithm <span class="citation" data-cites="mcmahan2016communication">(McMahan et al. <a href="#ref-mcmahan2016communication" role="doc-biblioref">2016</a>)</span> to obtain a new global model. One apparent issue with on-chain aggregation is storage. Neural networks consisting of millions or billions of parameters require storage space in the order of megabytes. With the current average block size at around 20 kilobytes <span class="citation" data-cites="avgblocksize">(“Ethereum Average Block Size Chart” <a href="#ref-avgblocksize" role="doc-biblioref">n.d.</a>)</span>, exchanging models on-chain does not scale well.</p>
<p><span class="citation" data-cites="kurtulmus2018trustless">(Kurtulmus and Daniel <a href="#ref-kurtulmus2018trustless" role="doc-biblioref">2018</a>)</span> outlines a solution to training a machine learning model using a predefined dataset. In this paradigm, one data owner submits a dataset along with an evaluation function. Workers use those in a race to produce a high-performance model, with the first accepted worker getting a reward. This allows for a valuation of machine-learning training in a decentralized marketplace. This creates a system similar to Bitcoin’s proof-of-work, where miners with valid blocks may not get rewarded for their work. With machine-learning training usually taking hours or days, rather than Bitcoin blocks taking 10 minutes to generate, the amount of wasted time is increased. Nonetheless, the freedom given to data owners for defining an evaluation function is an idea considered in this paper.</p>
<p>When rewarding nodes for their work, one must ensure that nodes are paid fairly. Indeed, the model training is highly dependent on quality data, so clients need to be incentivized not only to participate, but to participate honestly. Some reward mechanisms have been proposed to judge a client’s honesty. The traditional FedAvg algorithm, which weighs the model updates based on the <em>quantity</em> of training data used by each client, is reliant on the i.i.d assumption, which does not always hold up in decentralized systems, and heavily incentivizes dishonest clients to generate fake data or duplicate it.</p>
<p>One approach is to hold a test dataset, and compare the performance of each local model on this dataset. While this approach gives highly-reliable results, it assumes that <span class="math inline">\(MO\)</span> is willing to share his private testing dataset, which is against the premise of federated learning.</p>
<p>Another approach is to give each client a reputation score that gets updated with every model that he uploads <span class="citation" data-cites="zhao2019mobile">(Zhao et al. <a href="#ref-zhao2019mobile" role="doc-biblioref">2019</a>)</span>. Clients are then selected and rewarded based on their accumulated reputation. Unfortunately, in a decentralized and pseudonymous world, this approach suffers from a few pitfalls: First, it is prone to the cold-start problem, where clients with no reputation will have difficulty building one, regardless of the quality of their data. Indeed, only clients with multiple, diverse datasets will be able to build any meaningful reputation: most clients, who have high-quality specialized datasets, will have difficulty being selected. Second, building reputation does not mean that all one’s datasets will be of high quality: one can build a reputation for a specific domain, which will give him a high chance of getting selected for <em>any</em> domain, where the quality of his data may not be as high as his reputation indicates. Third, as a client builds a good reputation, the incentive to provide quality data decreases: he can now produce cheap low-quality datasets and get rewarded highly based on his past work. Conversely, a client who builds a bad reputation can simply start anew by generating a new identity.</p>
<h1 id="s:design"><span class="header-section-number">3</span> Design</h1>
<p>This section outlines our proposals for bringing together model owners and clients, aggregating model updates and paying nodes for their contributions.</p>
<p>The main components of our design are an off-chain aggregation server for storing models, a smart contract for rewarding clients, and client software for running the training.</p>
<figure>
<img src="/assets/images/posts/teach-a-framework-for-decentralized-federated-learning/workflow.png" id="fig:workflow" alt="" /><figcaption>General workflow <span label="fig:workflow"></span></figcaption>
</figure>
<h2 id="connecting-the-parties"><span class="header-section-number">3.1</span> Connecting the parties</h2>
<p>The main purpose of a model owner is finding data to train his model.Therefore, the creation of a stack capable of connecting workers and model owners has been implemented. The model owner is able to upload his model directly through a web interface. When the model’s file is selected, the model owner will be able to configure some parameters for the training such as round’s number, worker’s number required, minimum of workers in the pending pool, type of data required and other basic information such as a short description or the model’s name. Once this piece of information is filled, the model will be available on a marketplace via the web application to all workers. The smart contract will then be triggered to withdraw the fund from the model owner to pay the workers, which corresponds to the total reward that the model owner is willing to give for each round of training. The worker is now able to browse through the catalog and chose a model to train depending on the type of data he has. In order to avoid inappropriate data for the training, the model owner needs to specify a <em>check_data</em> function in his model. This refers to the different criteria that the worker’s data must respect. The model owner must also define a contribution function, which will be used to calculate workers’ rewards. This tells potential workers exactly how much value they can expect their data to generate. Once validation of the chosen model is done, the worker will be added to a pending pool until, the right amount of workers predefined by the model owner, is reached. Validate a model to train also trigger the smart contract that will block a deposit for the worker. This is an approach to limit Sybil attacks, where one replicates his data across several identities. Once reached, the server will then select randomly the right amount of workers from the pending pool then start the training.</p>
<h2 id="aggregating-model-updates"><span class="header-section-number">3.2</span> Aggregating model updates</h2>
<p>Once a client finishes training, he uploads his update and his contribution to the aggregation server. Upon receipt, the server stores a local copy of the client’s update and stores the worker’s contribution in the smart contract. Once all the clients have finished training, the aggregation server updates the global model using the average of all the client updates, weighted by their contribution scores. As such, FedAvg is the special case where the contribution function equals the number of training points. As the global model is updated, the smart contract starts rewarding the clients.</p>
<h2 id="rewarding-clients"><span class="header-section-number">3.3</span> Rewarding clients</h2>
<p>Each round of training refers to a contribution for the training but also a reward for the workers. These workers will be rewarded at the end of each round. The smart contract created upon, will be triggered and will pay the workers based on the performance and on the amount of reward allocated per round. This amount is calculated as the total of reward given by the model owner divided by the total of rounds.</p>
<h2 id="transparency-of-the-process"><span class="header-section-number">3.4</span> Transparency of the process</h2>
<p>In this architecture, little trust is needed from the workers to be confident they are rewarded accurately. Indeed, each worker has access to the global model, the contribution function, as well as their local dataset. They can therefore prove the aggregator’s honesty by simply running a round locally on their machine and computing the contribution. This value is exactly what the aggregator stores in the smart contract.</p>
<h1 id="s:local-training-loss-as-a-contribution-function"><span class="header-section-number">4</span> Local training loss as a contribution function</h1>
<p>We test our approach on the MNIST <span class="citation" data-cites="lecun1998gradient">(LeCun et al. <a href="#ref-lecun1998gradient" role="doc-biblioref">1998</a>)</span> dataset of digits. We split the training dataset into 20 equal subsets, and assigned each subset to a virtual client. We used a simple two-layer MLP with rectified linear unit pre-activations and a log-softmax output activation, and trained for 15 rounds (we considered one training epoch as one round)</p>
<p>We used the inverse of the local training loss as our contribution function. The rationale is the following: a capable model should be able to find patterns on data that is distributed similarly to what the model has been trained on. Therefore, high-quality data should cause it to generate a low training loss. Additionally, training it on a large amount of data should also help reducing the loss, Training loss therefore simultaneously incentivizes clients to not only train on good data, but also to train on a large quantity of it. Furthermore, as the training loss is needed to train the model regardless of the contribution function, using it to calculate the contribution adds little extra computation. In fact, only an averaging is required, and its computation is linear in the number of training points.</p>
<p>Before every training round, any number of clients could be replaced by malicious clients. We considered a malicious client as performing one of the following three attacks:</p>
<ol>
<li><p>Sybil attacks (client replicates his data across several identities)</p></li>
<li><p>Data duplication attacks (client duplicates his data)</p></li>
<li><p>Poisoning attacks (client uses random noise as training data)</p></li>
</ol>
<h2 id="results"><span class="header-section-number">4.1</span> Results</h2>
<p>We compared the test accuracy of our method to that of FedAvg for each attack and for any number of malicious clients from 0 to 19 (i.e. 95% of the data is malicious). Results follow.</p>
<h3 id="baseline-model-performance"><span class="header-section-number">4.1.1</span> Baseline Model Performance</h3>
<p>As a baseline check, we compare the model’s performance using both methods, when all clients are honest and provide quality data (Figure <a href="#fig:baseline-model-performance" data-reference-type="ref" data-reference="fig:baseline-model-performance">2</a>). Both methods achieve almost identical final scores of over 90%, and have similar learning curves. With the dataset being randomly shuffled and split equally between the clients, the local losses should be fairly similar, which explains the similarity of the learning curves.</p>
<figure>
<img src="/assets/images/posts/teach-a-framework-for-decentralized-federated-learning/baseline-model-performance.png" id="fig:baseline-model-performance" alt="" /><figcaption>Algorithm Accuracy in the honest setting<span label="fig:baseline-model-performance"></span></figcaption>
</figure>
<h3 id="contribution-evolution-over-time"><span class="header-section-number">4.1.2</span> Contribution evolution over time</h3>
<p>The primary motive for defining a contribution function is to prevent malicious clients from affecting model training and being rewarded as if they were honest. Figure <a href="#fig:contribution-evolution-over-time" data-reference-type="ref" data-reference="fig:contribution-evolution-over-time">3</a> shows the average contribution of malicious clients at every round, for the situation where 15% of the data is controlled by malicious clients, and those clients are present from the first round to the last.</p>
<figure>
<img src="/assets/images/posts/teach-a-framework-for-decentralized-federated-learning/contribution-evolution-over-time.png" id="fig:contribution-evolution-over-time" alt="" /><figcaption>Malicious clients’ contribution over time<span label="fig:contribution-evolution-over-time"></span></figcaption>
</figure>
<p>With standard federated averaging, the contribution is defined as the number of training points: in this simulation, FedAvg attributes each client 5% of the total contribution. With local training loss, the contribution of each malicious client drops to less than 1% of the total contribution. Because the loss function used in this simulation (negative log-likelihood) outputs a positive number, malicious clients would always receive <em>some</em> contribution. However, as this number approaches zero, so too does the incentive to cheat.</p>
<h3 id="performance-limit"><span class="header-section-number">4.1.3</span> Performance limit</h3>
<p>While training loss shows a better ability to detect and adjust against malicious data, this ability is dependent on the proportion of data being malicious. As shown in Figure <a href="#fig:performance-limit" data-reference-type="ref" data-reference="fig:performance-limit">4</a>, both methods lost significant capability when dealing with 20% or more malicious data. This could be remedied in a few ways. First, the model can be pre-trained by <span class="math inline">\(MO\)</span> using his local dataset. Second, <span class="math inline">\(MO\)</span> can add a penalty term either in the contribution function to reduce a client’s contribution, or in the data checking function to reject it entirely. This term can be based <em>e.g.</em> on a similarity measure between the client’s distribution and an expected distribution.</p>
<figure>
<img src="/assets/images/posts/teach-a-framework-for-decentralized-federated-learning/performance-limit.png" id="fig:performance-limit" alt="" /><figcaption>Algorithm Accuracy Based on % of Data that is Malicious<span label="fig:performance-limit"></span></figcaption>
</figure>
<h1 id="s:limitations-and-future-work"><span class="header-section-number">5</span> Limitations and Future Work</h1>
<p>This section outlines areas of improvement to be considered.</p>
<h2 id="centralized-aggregator"><span class="header-section-number">5.1</span> Centralized aggregator</h2>
<p>The high cost of storing models and averaging updates requires these operations to be done off-chain. Our framework makes use of a third-party secure aggregation server to perform this task. While the server is provably honest to the clients, <span class="math inline">\(MO\)</span> has to trust that the clients were truly selected randomly and that the model updates were done in accordance to the calculated contributions. Using decentralized storage such as IPFS <span class="citation" data-cites="benet2014ipfs">(Benet <a href="#ref-benet2014ipfs" role="doc-biblioref">2014</a>)</span> would help mitigate that issue and would give <span class="math inline">\(MO\)</span> full control over model updates. However, the open storage of machine learning models can be a privacy issue, and a third-party will still be required for the random selection of clients.</p>
<p>The clients could be selected randomly by making them solve a puzzle and send in a proof of work similar to how Bitcoin miners are selected: in this case, the first <span class="math inline">\(N\)</span> clients to complete the proof of work would be automatically selected to train, where <span class="math inline">\(N\)</span> is the number of workers specified by <span class="math inline">\(MO\)</span>. This would remove the need for a minimum worker pool, and would allow for randomness without a third-party. The minimum deposit requirement would be replaced by a difficulty parameter, similar to the ones adjusted by current blockchains. However, true randomness would only be achieved if all clients had the same processing power. As this is unlikely to be the case, this proof-of-work mechanism will favor clients with the most computing resources, and not necessarily those with the best data.</p>
<h2 id="predetermined-per-round-reward"><span class="header-section-number">5.2</span> Predetermined per-round reward</h2>
<p>The smart contract automatically calculates the reward per round as the total reward remaining to be paid divided by the number of rounds left. This reward is then spread among the clients according to their share of the total contribution for the round. This ensures that the smart contract has enough funds to allow clients to withdraw their balance at any time. However, this also pays out the same total reward on each round, although the model’s improvement slows down over time. This should be reflected in the total rewards paid. <span class="math inline">\(MO\)</span> can currently achieve this by withdrawing funds before a round starts, reducing the total reward. This requires him to download the updated global model and calculate its performance, lacking the convenience of an automated method.</p>
<h1 id="conclusion"><span class="header-section-number">6</span> Conclusion</h1>
<p>In this paper, we have outlined a transparent, provably-honest, general-purpose framework for decentralized federated learning. This framework allows parties to connect together and perform training sessions regardless of the domain in which their data lies. It requires little trust from the parties and is highly configurable my the model owner, giving him control over the quality of the data being submitted by clients.</p>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-benet2014ipfs">
<p>Benet, Juan. 2014. “Ipfs-Content Addressed, Versioned, P2p File System.” <em>arXiv Preprint arXiv:1407.3561</em>.</p>
</div>
<div id="ref-avgblocksize">
<p>“Ethereum Average Block Size Chart.” n.d. Accessed April 23, 2020. <a href="https://etherscan.io/chart/blocksize">https://etherscan.io/chart/blocksize</a>.</p>
</div>
<div id="ref-kim2019blockchained">
<p>Kim, Hyesung, Jihong Park, Mehdi Bennis, and Seong-Lyun Kim. 2019. “Blockchained on-Device Federated Learning.” <em>IEEE Communications Letters</em>.</p>
</div>
<div id="ref-kurtulmus2018trustless">
<p>Kurtulmus, A Besir, and Kenny Daniel. 2018. “Trustless Machine Learning Contracts; Evaluating and Exchanging Machine Learning Models on the Ethereum Blockchain.” <em>arXiv Preprint arXiv:1802.10185</em>.</p>
</div>
<div id="ref-lecun1998gradient">
<p>LeCun, Yann, Léon Bottou, Yoshua Bengio, and Patrick Haffner. 1998. “Gradient-Based Learning Applied to Document Recognition.” <em>Proceedings of the IEEE</em> 86 (11): 2278–2324.</p>
</div>
<div id="ref-mcmahan2016communication">
<p>McMahan, H Brendan, Eider Moore, Daniel Ramage, Seth Hampson, and others. 2016. “Communication-Efficient Learning of Deep Networks from Decentralized Data.” <em>arXiv Preprint arXiv:1602.05629</em>.</p>
</div>
<div id="ref-zhao2019mobile">
<p>Zhao, Yang, Jun Zhao, Linshan Jiang, Rui Tan, and Dusit Niyato. 2019. “Mobile Edge Computing, Blockchain and Reputation-Based Crowdsourcing Iot Federated Learning: A Secure, Decentralized and Privacy-Preserving System.” <em>arXiv Preprint arXiv:1906.10893</em>.</p>
</div>
</div>
